# ADR Summary: Centralized Model Management Architecture

**Date:** 2025-11-09
**Created:** 2 new ADRs documenting the data-driven model management system

---

## What Was Created

### 1. [centralized-model-registry.md](../docs/development/adrs/centralized-model-registry.md) - 20KB

**Core Architecture Documentation**

Documents the centralized model registry system that prevents hardcoded model lists and enables automatic adaptation to AI model market changes.

**Key Sections:**
- **Context**: Why AI model economics are dynamic (costs down, quality up)
  - Real example: Opus 4.1 ($15-75) ‚Üí Sonnet 4.5 ($3-15) with same performance
- **Decision**: Centralized registry with band-based selection
- **Components**:
  - models.csv (36 models, single source of truth)
  - bands_config.json (9 band categories with centralized criteria)
  - BandSelector (query engine for data-driven selection)
  - model_evaluator (tool for adding models from OpenRouter URLs)
- **Benefits**:
  - Automatic cost optimization (80% savings example)
  - Performance tracking over time
  - Graceful model deprecation
  - Domain-specific tool creation (50 lines vs 500+)
  - Vendor neutrality
- **Examples**: 3 real-world scenarios with code
- **Migration Plan**: 4-week timeline

**Purpose:** Ensures the architecture vision isn't forgotten when developers make changes

---

### 2. [dynamic-model-availability.md](../docs/development/adrs/dynamic-model-availability.md) - 15KB

**Failover and Availability Pattern Documentation**

Documents the distinction between free model transient availability vs paid model permanent failures.

**Critical Distinctions:**

| Model Type | Availability Pattern | Failure Handling |
|------------|---------------------|------------------|
| **Free models** | Transient (404 today, works tomorrow) | Multiple failover attempts within free tier |
| **Paid models** | Permanent (99.9% uptime expected) | Alert for removal, mark as deprecated |

**Key Sections:**
- **Context**: Free models have dynamic availability based on:
  - Privacy settings
  - Provider requirements
  - Time of day / demand
  - Geographic region
  - Rate limits
- **Decision**: Multi-tier failover with graceful degradation
- **Architecture**:
  - Failover hierarchy (free ‚Üí economy ‚Üí value)
  - Availability detection and caching
  - Retry logic with exponential backoff
  - Cost tracking for failovers
- **Paid Model Handling**: Different strategy - failures trigger alerts for manual deprecation
- **Examples**: 4 scenarios from successful free tier to budget enforcement
- **Migration Plan**: 4-week implementation

**Purpose:** Documents that free models aren't "broken" - they have transient availability requiring sophisticated failover

---

## Key Insights Captured

### 1. Band Thresholds Enable Industry Adaptation

**Quote from user:**
> "Over time I expect that costs will come down and quality will go up. For example, it used to be that Opus 4.1 was the most expensive but best performant model. With the release of Sonnet 4.5, it now outperforms Opus 4.1 at a lower cost."

**Documented Solution:**
- Band thresholds in bands_config.json can be adjusted as industry improves
- Models automatically re-classified when thresholds change
- No code changes needed - just configuration updates

**Example:**
```json
// 2025 Standards
{"performance_bands": {"excellent": {"min_score": 75.1}}}

// 2026 Standards (industry improved)
{"performance_bands": {"excellent": {"min_score": 80.0}}}

// Result: Models automatically re-ranked
```

### 2. Model Evaluation Workflow

**Quote from user:**
> "I would use automated_evaluation_criteria.py and then the openrouter url for the new model to get it added."

**Documented Workflow:**
```
New Model Released (e.g., Sonnet 4.5)
  ‚Üì
model_evaluator tool ‚Üí OpenRouter URL
  ‚Üì
automated_evaluation_criteria.py ‚Üí Scrapes benchmarks
  ‚Üì
Qualification check (HumanEval, cost, context)
  ‚Üì
Add to models.csv ‚Üí Automatic classification via bands
  ‚Üì
BandSelector picks it up ‚Üí No code changes
  ‚Üì
Consensus tools use it ‚Üí Immediate benefit
```

### 3. Domain-Specific Tool Pattern

**Quote from user:**
> "If we ever wanted to have a consensus tool focused on something other than code review, we could duplicate the advanced consensus tool, and change the roles to what we needed and have replicated the whole structure easily."

**Documented Pattern:**
```python
# security_consensus.py - 50 lines
class SecurityConsensusTool(WorkflowTool):
    def _get_roles_for_tier(self, tier):
        if tier == 1:
            return ["security_checker", "vulnerability_scanner", "compliance_validator"]
        elif tier == 2:
            return [
                # Tier 1 roles +
                "penetration_tester", "security_architect", "threat_modeler",
            ]
        # ... inherits ALL BandSelector logic automatically
```

### 4. Free Model Availability Pattern

**Quote from user:**
> "The challenge with the free models is that they are limited by the privacy settings and the providers that meet those requirements at a given time. So for a given model, a given model may or may not be available when a call is made."

**Documented Solution:**
- Free models: Multiple failover attempts within tier (transient unavailability)
- Paid models: Single attempt, alert if fails (permanent issue)
- Automatic fallback: Free ‚Üí Economy ‚Üí Value
- Cost tracking: Monitor failover costs
- User configuration: Strict free-only mode vs cost-optimized mode

**Failover Flow:**
```
1. Try free_model_1 ‚Üí 404 (privacy policy)
2. Try free_model_2 ‚Üí 429 (rate limited)
3. Try free_model_3 ‚Üí 200 ‚úÖ (success, still $0)

// Next request 5 minutes later
1. Try free_model_1 ‚Üí 200 ‚úÖ (now available)
```

---

## Current Implementation Status

### ‚úÖ Completed
- models.csv (36 models with comprehensive metadata)
- bands_config.json (9 band categories)
- BandSelector (query engine with 12+ methods)
- model_evaluator (tool for adding models)
- automated_evaluation_criteria.py (benchmark scraping)

### ‚ö†Ô∏è Partial Implementation
**Issue:** Consensus tools have hardcoded model lists

**Example from smart_consensus_v2.py:**
```python
# HARDCODED - Should use BandSelector!
FREE_MODELS = [
    "deepseek/deepseek-chat:free",
    "meta-llama/llama-3.3-70b-instruct:free",
    ...
]
```

**Should be:**
```python
from tools.custom.band_selector import BandSelector
selector = BandSelector()
free_models = selector.get_models_by_cost_tier("free", limit=5)
```

### üìã Remaining Work

**4-Week Migration Plan:**

**Week 1:** Add availability checking
- Implement AvailabilityCache
- Implement health check logic
- Test with free models

**Week 2:** Implement failover
- Add get_available_models_with_failover()
- Update consensus tools to use failover
- Add metrics collection

**Week 3:** Remove hardcoded lists
- Update smart_consensus_v2 to use BandSelector
- Test automatic model selection
- Verify cost tracking

**Week 4:** Monitoring and alerts
- Implement FailoverMetrics
- Configure alerts for paid model failures
- Document user-facing behavior

---

## Architectural Principles Documented

### 1. Configuration Over Code
Models should be selected via centralized configuration (models.csv + bands_config.json), not hardcoded in tool implementations.

### 2. Data-Driven Selection
BandSelector queries registry using band criteria - tools don't need to know about specific models.

### 3. Automatic Adaptation
When models.csv or bands_config.json updates, all tools automatically adapt without code changes.

### 4. Graceful Degradation
When preferred models unavailable, automatically fall back to next-best alternatives.

### 5. Free vs Paid Distinction
- Free models: Transient availability, need failover
- Paid models: Permanent availability, failures indicate deprecation

### 6. Cost Optimization
Always prefer lower-cost tiers (free ‚Üí economy ‚Üí value) with automatic failover.

### 7. Domain Flexibility
New consensus tools (security, performance, etc.) easy to create by changing roles only.

---

## What These ADRs Prevent

### ‚ùå Won't Happen Again:
1. Forgetting the centralized registry exists
2. Building tools with hardcoded model lists
3. Missing cost optimization opportunities (Sonnet 4.5 over Opus 4.1)
4. Manual model updates requiring code changes
5. Treating free model 404s as permanent failures
6. Not implementing failover for transient unavailability
7. Confusing free model transient issues with paid model permanent failures

### ‚úÖ Will Be Preserved:
1. Data-driven architecture principles
2. Band threshold concept for industry adaptation
3. Model evaluation workflow (OpenRouter URL ‚Üí models.csv)
4. Domain-specific tool creation pattern
5. Free model failover strategy
6. Paid model deprecation alerts
7. Automatic cost optimization

---

## Files Updated

### New ADRs Created
1. `docs/development/adrs/centralized-model-registry.md` (20KB)
2. `docs/development/adrs/dynamic-model-availability.md` (15KB)

### Updated Files
1. `docs/development/adrs/README.md` - Added foundational ADRs section

### Reference Documents
1. `tmp_cleanup/.tmp-model-registry-architecture-20251109.md` (30KB) - Detailed technical analysis
2. `tmp_cleanup/.tmp-consensus-architecture-gap-analysis-20251109.md` (30KB) - Gap analysis
3. `COMPLETE_TOOL_LLM_MATRIX.md` (25KB) - All tools documented

---

## Next Actions

### Immediate (This Week)
1. **Review ADRs** - Confirm architecture accurately documented
2. **Plan migration** - Decide on 4-week timeline or faster

### Week 1-4 (Migration)
1. Implement availability checking and failover
2. Remove hardcoded model lists from consensus tools
3. Add monitoring and alerts
4. Update documentation

### Ongoing
1. Use model_evaluator when new models release
2. Adjust band thresholds as industry improves
3. Create domain-specific consensus tools as needed
4. Monitor failover metrics and costs

---

## Developer Guidance

**Before making changes to consensus tools, READ:**
1. `centralized-model-registry.md` - Understand the data-driven architecture
2. `dynamic-model-availability.md` - Understand failover patterns

**When adding new models:**
1. Use model_evaluator tool with OpenRouter URL
2. Tool adds to models.csv automatically
3. BandSelector picks it up
4. Consensus tools use it (no code changes)

**When creating new consensus tools:**
1. Extend WorkflowTool
2. Define roles for each tier
3. Use BandSelector for model selection
4. Inherit all failover logic automatically

**When you see hardcoded model lists:**
1. This is technical debt
2. Replace with BandSelector calls
3. Reference centralized-model-registry.md ADR

---

**These ADRs ensure the architecture vision is permanently documented and won't be lost as the project evolves.**
