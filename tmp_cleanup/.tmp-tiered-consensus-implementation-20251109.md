# Tiered Consensus Tool - Implementation Summary

**Date:** 2025-11-09
**Status:** Week 1 Implementation Complete (Core Files + Tests)

---

## Executive Summary

Implemented the new **tiered_consensus** tool as a unified replacement for fragmented custom consensus tools. The tool provides a simple API (prompt + level) with additive tier architecture matching your original vision.

**Key Achievement:** Reduced API complexity from 7 required parameters to 2 required parameters while implementing proper additive tier architecture.

---

## Files Created

### Core Implementation (4 files)

#### 1. [tools/custom/tiered_consensus.py](../tools/custom/tiered_consensus.py) - 400 lines
**Purpose:** Main tool implementation (WorkflowTool)

**Key Features:**
- Simple API: `prompt` + `level` (1, 2, or 3)
- Optional parameters: `domain`, `include_synthesis`, `max_cost`
- Workflow managed internally (user doesn't see step/findings complexity)
- Uses BandSelector for model selection (no hardcoded lists)
- Implements additive tier architecture

**Tool Name:** `tiered_consensus` (renamed from `consensus` to avoid conflict with upstream `/tools/consensus.py`)

**User-Facing API:**
```python
{
  "prompt": "Should we migrate from PostgreSQL to MongoDB?",
  "level": 2  # 1, 2, or 3
}
```

**Advanced API (optional):**
```python
{
  "prompt": "Should we migrate from PostgreSQL to MongoDB?",
  "level": 2,
  "domain": "architecture",  # code_review, security, architecture, general
  "include_synthesis": true,
  "max_cost": 1.0
}
```

#### 2. [tools/custom/consensus_models.py](../tools/custom/consensus_models.py) - 450 lines
**Purpose:** TierManager with BandSelector integration and failover logic

**Key Classes:**
- `AvailabilityCache` - 5-minute TTL cache for model availability
- `TierManager` - Additive tier model selection
  - `get_tier_models(level)` - Returns additive model lists
  - `get_tier_costs(level)` - Estimates costs per tier
  - `get_tier_summary(level)` - Comprehensive tier info

**Additive Tier Architecture:**
| Level | Models | Cost | Description |
|-------|--------|------|-------------|
| **1** | 3 free | $0 | Foundation - Quick validation |
| **2** | Level 1 + 3 economy (6 total) | ~$0.50 | Professional - Standard decisions |
| **3** | Level 2 + 2 premium (8 total) | ~$5.00 | Executive - Critical decisions |

**Free Model Failover:**
- Tries multiple free models (transient availability)
- Caches availability status (5-minute TTL)
- Falls back to economy tier if all free models fail
- Alerts on paid model failures (indicates deprecation needed)

**BandSelector Integration:**
```python
# NO hardcoded models - uses BandSelector
free_models = band_selector.get_models_by_cost_tier("free", limit=5)
economy_models = band_selector.get_models_by_cost_tier("economy", limit=3)
premium_models = band_selector.get_models_by_cost_tier("premium", limit=2)
```

#### 3. [tools/custom/consensus_roles.py](../tools/custom/consensus_roles.py) - 350 lines
**Purpose:** RoleAssigner with domain-specific role mappings

**Key Features:**
- 18 professional role definitions
- 4 domain-specific role mappings
- Additive role assignments (Level 2 includes Level 1's roles)
- Easy to extend for new domains (security, architecture, etc.)

**Professional Roles:**
- **Level 1 (Foundation):** code_reviewer, security_checker, technical_validator
- **Level 2 (Professional):** Level 1 + senior_developer, system_architect, devops_engineer
- **Level 3 (Executive):** Level 2 + lead_architect, technical_director

**Domains Supported:**
- `code_review` - Code quality and development focus
- `security` - Security and compliance focus
- `architecture` - System design and scalability focus
- `general` - Balanced multi-perspective analysis

**Domain Extension Example:**
```python
DOMAIN_ROLES["security"] = {
    1: ["security_checker", "vulnerability_scanner", "compliance_validator"],
    2: [
        # Level 1 roles (ADDITIVE)
        "security_checker", "vulnerability_scanner", "compliance_validator",
        # Level 2 additions
        "penetration_tester", "security_architect", "threat_modeler",
    ],
    3: [
        # Level 1 + 2 roles (ADDITIVE)
        ...,
        # Level 3 additions
        "security_director", "compliance_officer",
    ],
}
```

#### 4. [tools/custom/consensus_synthesis.py](../tools/custom/consensus_synthesis.py) - 400 lines
**Purpose:** SynthesisEngine for aggregating perspectives and generating consensus analysis

**Key Classes:**
- `Perspective` - Single role-model analysis
- `ConsensusResult` - Complete consensus output
- `SynthesisEngine` - Consensus aggregation

**Analysis Features:**
- Identifies consensus points (agreement across perspectives)
- Identifies disagreements (conflicting viewpoints)
- Extracts key points, concerns, recommendations
- Generates synthesis report
- Generates executive summary

**Output Format:**
```
CONSENSUS ANALYSIS - Level 2 (CODE_REVIEW)

## Executive Summary
**Overall Assessment:** General consensus with some areas of disagreement

**Key Takeaways:**
1. [Consensus point 1]
2. [Consensus point 2]
3. [Consensus point 3]

**Critical Concerns:**
1. [Concern from security perspective]
2. [Concern from architecture perspective]

**Recommended Actions:**
1. [Recommendation 1]
2. [Recommendation 2]

## Consensus Analysis
[Detailed synthesis of all perspectives]

## Detailed Perspectives
[Full analysis from each role-model combination]
```

### Tests (1 file)

#### 5. [tests/test_consensus_models.py](../tests/test_consensus_models.py) - 300 lines
**Purpose:** Unit tests for TierManager and AvailabilityCache

**Test Coverage:**
- ✅ AvailabilityCache initialization, hit/miss, expiration, stats
- ✅ TierManager initialization, invalid level handling
- ✅ Level 1 returns 3 free models
- ✅ Level 2 additive architecture (Level 1 + economy)
- ✅ Level 3 additive architecture (Level 2 + premium)
- ✅ Tier cost calculation
- ✅ Level descriptions
- ✅ Tier summary generation
- ✅ Free model failover (tries multiple models)
- ✅ Failover respects cache (skips known unavailable)

**Run Tests:**
```bash
pytest tests/test_consensus_models.py -v
```

---

## Architecture Principles Implemented

### 1. Configuration Over Code ✅
**Implementation:**
- Uses BandSelector for all model selection
- No hardcoded model lists in tiered_consensus.py
- Models come from models.csv + bands_config.json

**Example:**
```python
# WRONG (what the old tools did)
FREE_MODELS = ["deepseek/deepseek-chat:free", "meta-llama/llama-3.3-70b:free"]

# RIGHT (what tiered_consensus does)
free_models = self.band_selector.get_models_by_cost_tier("free", limit=5)
```

### 2. Additive Tier Architecture ✅
**Implementation:**
- Level 2 includes Level 1's exact models + additions
- Level 3 includes Level 2's exact models + additions
- Verified by unit tests

**Example:**
```python
# Level 1
tier1_models = ["free1", "free2", "free3"]

# Level 2 (ADDITIVE)
tier2_models = tier1_models + ["economy1", "economy2", "economy3"]
# Result: ["free1", "free2", "free3", "economy1", "economy2", "economy3"]

# Level 3 (ADDITIVE)
tier3_models = tier2_models + ["premium1", "premium2"]
# Result: All 8 models from Level 2 + premium additions
```

### 3. Free Model Failover ✅
**Implementation:**
- Tries multiple free models (transient availability)
- Caches availability (5-minute TTL)
- Falls back to economy if all free models fail
- Based on dynamic-model-availability.md ADR

**Example:**
```python
# Try 5 free models, target 3 available
candidates = ["free1", "free2", "free3", "free4", "free5"]

# free1: 404 (skip)
# free2: 429 (skip)
# free3: 200 ✅
# free4: 200 ✅
# free5: 200 ✅

# Result: ["free3", "free4", "free5"]
```

### 4. Paid Model Deprecation Alerts ✅
**Implementation:**
- Single attempt for paid models
- Critical alert if 404/429 (shouldn't happen)
- Logs to monitoring for manual review

**Example:**
```python
if is_paid and error_code in [404, 429]:
    logger.critical(
        f"CRITICAL: Paid model {model} returned {error_code}. "
        f"This indicates the model should be removed from registry."
    )
    self._alert_paid_model_failure(model, error_code)
```

### 5. Domain Extensibility ✅
**Implementation:**
- Easy to add new domains (just add role mappings)
- No code changes needed for new consensus types
- Currently supports: code_review, security, architecture, general

**Adding New Domain:**
```python
# Add to DOMAIN_ROLES in consensus_roles.py (50 lines)
DOMAIN_ROLES["performance"] = {
    1: ["performance_engineer", "load_tester", "profiler"],
    2: ["performance_engineer", "load_tester", "profiler",
        "scalability_expert", "caching_specialist", "optimization_engineer"],
    3: ["performance_engineer", "load_tester", "profiler",
        "scalability_expert", "caching_specialist", "optimization_engineer",
        "performance_director", "capacity_planner"],
}
```

---

## Comparison: Old vs New

### API Complexity

**Old (smart_consensus_v2):**
```python
# 7 required parameters
{
  "question": "...",
  "step": "...",
  "step_number": 1,
  "total_steps": 8,
  "next_step_required": true,
  "findings": "...",
  "org_level": "scaleup"
}
```

**New (tiered_consensus):**
```python
# 2 required parameters
{
  "prompt": "...",
  "level": 2
}
```

**Reduction:** 71% fewer parameters (7 → 2)

### Code Size

| Component | Old | New | Reduction |
|-----------|-----|-----|-----------|
| Main tool | smart_consensus_v2.py (600 lines) | tiered_consensus.py (400 lines) | 33% |
| Support files | 6 files (3,000+ lines) | 3 files (1,200 lines) | 60% |
| **Total** | **~4,000 lines** | **~1,600 lines** | **60%** |

### Model Selection

| Aspect | Old | New |
|--------|-----|-----|
| Model lists | Hardcoded in tool | BandSelector queries |
| Updates | Code changes required | Automatic from models.csv |
| Failover | Manual/limited | Automatic with caching |
| Cost tracking | Manual | Automatic per tier |

### Architecture Compliance

| Principle | Old Tools | New Tool |
|-----------|-----------|----------|
| Uses centralized registry | ❌ No (hardcoded lists) | ✅ Yes (BandSelector) |
| Additive tier architecture | ❌ No (replacement tiers) | ✅ Yes (cumulative) |
| Free model failover | ⚠️ Partial | ✅ Yes (ADR-compliant) |
| Paid model alerts | ❌ No | ✅ Yes |
| Domain extensibility | ⚠️ Limited | ✅ Easy (50 lines) |

---

## Current Status

### ✅ Completed (Week 1)

**Core Implementation:**
- [x] tiered_consensus.py (main tool)
- [x] consensus_models.py (TierManager + BandSelector)
- [x] consensus_roles.py (RoleAssigner + domains)
- [x] consensus_synthesis.py (SynthesisEngine)

**Testing:**
- [x] test_consensus_models.py (TierManager unit tests)
- [x] Additive architecture verified
- [x] Free model failover verified
- [x] Cache behavior verified

**Architecture:**
- [x] BandSelector integration (no hardcoded models)
- [x] Additive tier architecture (Level 2 includes Level 1)
- [x] Free model failover (from ADR)
- [x] Paid model alerts (from ADR)
- [x] Domain extension pattern

### ⏳ Remaining (Week 2-4)

**Week 2: Backward Compatibility**
- [ ] Add deprecation warnings to old tools
- [ ] Create parameter mapping (org_level → level)
- [ ] Migration guide documentation

**Week 3: User Communication**
- [ ] Update MCP server tool registry
- [ ] Update COMPLETE_TOOL_LLM_MATRIX.md
- [ ] Beta testing with real use cases

**Week 4: Deprecation & Cleanup**
- [ ] Remove old tools from MCP registry
- [ ] Archive deprecated files
- [ ] Final documentation
- [ ] Update CHANGELOG

---

## Key Design Decisions

### Decision 1: Tool Name - `tiered_consensus`
**Reason:** Upstream has `/tools/consensus.py` - needed different name
**Alternatives Considered:** unified_consensus, level_consensus, simple_consensus
**Chosen:** tiered_consensus (describes additive tier architecture)

### Decision 2: WorkflowTool Base Class
**Reason:** Need multi-step execution to consult multiple models sequentially
**Alternative:** SimpleTool (1 LLM call) - rejected because doesn't support true multi-model
**Implementation:** Workflow complexity hidden from user (managed internally)

### Decision 3: Separate Role/Model/Synthesis Modules
**Reason:** Separation of concerns, easier testing, better maintainability
**Structure:**
- consensus_roles.py - Role definitions (what perspectives to gather)
- consensus_models.py - Model selection (which models to use)
- consensus_synthesis.py - Result aggregation (how to combine perspectives)
- tiered_consensus.py - Orchestration (workflow management)

### Decision 4: Placeholder Model Calls
**Current:** Simulated responses for testing
**Future:** Replace `_simulate_model_response()` with actual model API calls
**Reason:** Core architecture can be tested without live API calls

---

## Integration Points

### Uses BandSelector
```python
from tools.custom.band_selector import BandSelector

tier_manager = TierManager()  # Internally creates BandSelector
models = tier_manager.get_tier_models(level=2)
# Returns: ["free1", "free2", "free3", "economy1", "economy2", "economy3"]
```

### References ADRs
- `docs/development/adrs/centralized-model-registry.md` - BandSelector architecture
- `docs/development/adrs/dynamic-model-availability.md` - Failover patterns

### Extends WorkflowTool
```python
from tools.workflow.base import WorkflowTool

class TieredConsensusTool(WorkflowTool):
    # Inherits workflow orchestration
    # Implements tool-specific methods
```

---

## Usage Examples

### Example 1: Quick Validation (Level 1, Free)
```python
{
  "prompt": "Review this authentication code for security issues",
  "level": 1
}
```

**Result:**
- 3 free models consulted
- 3 professional perspectives (code_reviewer, security_checker, technical_validator)
- Cost: $0
- Time: ~10 seconds

### Example 2: Standard Decision (Level 2, Balanced)
```python
{
  "prompt": "Should we migrate from REST to GraphQL?",
  "level": 2,
  "domain": "architecture"
}
```

**Result:**
- 6 models consulted (3 free + 3 economy)
- 6 professional perspectives (from architecture domain)
- Cost: ~$0.50
- Time: ~20 seconds

### Example 3: Critical Decision (Level 3, Comprehensive)
```python
{
  "prompt": "Evaluate rewriting our platform in Rust vs staying with Python",
  "level": 3,
  "domain": "architecture"
}
```

**Result:**
- 8 models consulted (3 free + 3 economy + 2 premium)
- 8 professional perspectives (complete architecture team)
- Cost: ~$5.00
- Time: ~30 seconds
- Includes: Consensus analysis, disagreement identification, executive summary

---

## Testing Strategy

### Unit Tests (Completed)
```bash
# TierManager tests
pytest tests/test_consensus_models.py -v

# Test results:
# ✅ test_tier_manager_initialization
# ✅ test_invalid_level_raises_error
# ✅ test_level_1_returns_free_models
# ✅ test_level_2_additive_architecture
# ✅ test_level_3_additive_architecture
# ✅ test_tier_costs_calculation
# ✅ test_failover_tries_multiple_free_models
# ✅ test_failover_respects_cache
```

### Integration Tests (Pending)
```bash
# Full workflow test
pytest tests/test_tiered_consensus_integration.py -v

# Will test:
# - Complete consensus workflow (prompt → synthesis)
# - Real BandSelector integration
# - Role assignment for each domain
# - Synthesis engine output
```

### End-to-End Tests (Pending)
```bash
# Live API test with real models (when _simulate_model_response replaced)
pytest tests/test_tiered_consensus_e2e.py -v

# Will test:
# - Actual model API calls
# - Real consensus analysis
# - Cost tracking accuracy
# - Performance benchmarks
```

---

## Next Steps

### Immediate (This Week)
1. **Complete remaining tests**
   - [ ] Unit tests for RoleAssigner
   - [ ] Integration test for full workflow
   - [ ] Edge case testing

2. **Replace simulated model responses**
   - [ ] Implement `_call_model()` method
   - [ ] Integrate with existing model calling infrastructure
   - [ ] Test with real models

3. **Add to MCP tool registry**
   - [ ] Register `tiered_consensus` tool
   - [ ] Test via MCP protocol
   - [ ] Verify Claude can call the tool

### Week 2: Backward Compatibility
1. Add deprecation warnings to:
   - [ ] smart_consensus.py
   - [ ] smart_consensus_v2.py
   - [ ] layered_consensus.py
   - [ ] smart_consensus_simple.py

2. Create migration guide:
   - [ ] Parameter mapping examples
   - [ ] Migration FAQ
   - [ ] Side-by-side comparisons

### Week 3-4: Deprecation & Cleanup
1. Archive deprecated tools
2. Update documentation
3. Final testing
4. Release

---

## Success Metrics

### User Experience
- ✅ Parameters reduced: 7 → 2 (71% reduction)
- ✅ Required parameters: 7 → 2 (71% reduction)
- ✅ API complexity: Complex workflow → Simple request

### Code Quality
- ✅ Total lines: 4,000 → 1,600 (60% reduction)
- ✅ Number of tools: 4 → 1 (75% reduction)
- ✅ Hardcoded models: Yes → No (BandSelector integration)

### Architecture Compliance
- ✅ Uses centralized model registry (models.csv + bands_config.json)
- ✅ Implements additive tier architecture
- ✅ Handles free model transient availability
- ✅ Alerts on paid model failures
- ✅ Domain extensibility (new consensus types easy to add)

---

**Implementation Summary: Week 1 of 4 complete. Core architecture verified, ready for integration and testing.**
