# Custom Consensus Tools Deprecation & Replacement Plan

**Date:** 2025-11-09
**Goal:** Replace fragmented consensus tools with single unified tool matching original intent

---

## Executive Summary

**Current State:** 10 consensus-related files with overlapping functionality, complex parameters, hardcoded models
**Desired State:** 1 unified consensus tool with simple API (level + prompt)
**Migration Path:** 4-week deprecation with backward compatibility period

---

## 1. Files to Deprecate

### Primary Consensus Tools (4 files)
```
tools/custom/layered_consensus.py          - SimpleTool (1 LLM call, simulated perspectives)
tools/custom/smart_consensus.py            - WorkflowTool (complex config, many features)
tools/custom/smart_consensus_v2.py         - WorkflowTool (role-based, hardcoded models)
tools/custom/smart_consensus_simple.py     - Unknown (needs analysis)
```

### Support Modules (6 files)
```
tools/custom/smart_consensus_cache.py      - Caching infrastructure
tools/custom/smart_consensus_recovery.py   - Error recovery strategies
tools/custom/smart_consensus_streaming.py  - Token optimization
tools/custom/smart_consensus_config.py     - Configuration profiles
tools/custom/smart_consensus_health.py     - Health monitoring
tools/custom/smart_consensus_monitoring.py - Metrics collection
```

**Decision:** Keep useful support modules, deprecate rest

---

## 2. Current Problems

### Problem 1: Complex Parameter Requirements

**layered_consensus.py:**
- Required: `question`
- Optional: `org_level`, `model_count`, `layers`, `cost_threshold`
- 5 parameters total

**smart_consensus_v2.py:**
- Required: `question`, `step`, `step_number`, `total_steps`, `next_step_required`, `findings`
- Optional: `org_level`
- 7 parameters total (workflow complexity)

**smart_consensus.py:**
- 15+ configuration options via SmartConsensusConfig
- Overwhelming for users

### Problem 2: Hardcoded Model Lists

**smart_consensus_v2.py (lines 108-122):**
```python
# HARDCODED - Violates centralized registry architecture
FREE_MODELS = [
    "deepseek/deepseek-chat:free",
    "meta-llama/llama-3.3-70b-instruct:free",
    "qwen/qwen-2.5-coder-32b-instruct:free",
    "microsoft/phi-4-reasoning:free",
    "meta-llama/llama-3.1-405b-instruct:free",
]

PREMIUM_MODELS = [
    "anthropic/claude-opus-4.1",
    "openai/gpt-5",
    "google/gemini-2.5-pro",
    "deepseek/deepseek-r1-0528",
    "mistralai/mistral-large-2411",
]
```

**Should use:** BandSelector for data-driven selection

### Problem 3: Not Additive Architecture

**Original Intent:**
- Level 1: 3 free models
- Level 2: Level 1's models + 3 medium-cost models (8 total)
- Level 3: Level 2's models + 2 premium models (10 total)

**Current Implementation:**
- Each org_level selects DIFFERENT models (replacement, not additive)
- User doesn't see cumulative perspectives

### Problem 4: SimpleTool vs WorkflowTool Confusion

**layered_consensus.py:**
- Extends SimpleTool (makes 1 LLM call)
- Simulates multiple perspectives in single response
- NOT true multi-model consensus

**smart_consensus_v2.py:**
- Extends WorkflowTool (makes multiple LLM calls)
- True multi-model consensus
- But workflow complexity exposed to user

---

## 3. Replacement Design: `consensus` Tool

### 3.1 User-Facing API (SIMPLE)

**Minimal Parameters:**
```python
{
  "prompt": "Should we migrate from PostgreSQL to MongoDB?",
  "level": 2  # 1, 2, or 3
}
```

**Optional Advanced Parameters:**
```python
{
  "prompt": "Should we migrate from PostgreSQL to MongoDB?",
  "level": 2,

  # Optional overrides (99% of users won't need these)
  "domain": "code_review",  # code_review, security, architecture, general
  "include_synthesis": true,  # Generate synthesis report (default: true)
  "max_cost": 1.0  # Override cost limit (default: based on level)
}
```

### 3.2 Additive Tier Architecture

**Level 1: Foundation (3 models, $0 cost)**
```python
# BandSelector query
tier1_models = selector.get_models_by_cost_tier("free", limit=3)
# Example: ["deepseek-chat:free", "llama-3.3-70b:free", "qwen-coder:free"]

roles = ["code_reviewer", "security_checker", "technical_validator"]
```

**Level 2: Professional (Level 1 + 3 models, ~$0.50 cost)**
```python
# ADDITIVE: Include Level 1's exact models
tier2_models = tier1_models + selector.get_models_by_cost_tier("economy", limit=3)
# Example: Level 1 + ["gemini-flash", "o4-mini", "qwen3-coder"]

roles = [
    # Level 1 roles
    "code_reviewer", "security_checker", "technical_validator",
    # Level 2 additions
    "senior_developer", "system_architect", "devops_engineer"
]
```

**Level 3: Executive (Level 2 + 2 models, ~$5.00 cost)**
```python
# ADDITIVE: Include Level 2's exact models
tier3_models = tier2_models + selector.get_models_by_cost_tier("premium", limit=2)
# Example: Level 2 + ["opus-4.1", "gpt-5"]

roles = [
    # Level 1 + 2 roles
    "code_reviewer", "security_checker", "technical_validator",
    "senior_developer", "system_architect", "devops_engineer",
    # Level 3 additions
    "lead_architect", "technical_director"
]
```

### 3.3 Implementation Architecture

**File Structure:**
```
tools/custom/consensus.py           # Main tool implementation
tools/custom/consensus_models.py    # Tier definitions using BandSelector
tools/custom/consensus_roles.py     # Role definitions by domain
```

**Key Components:**

1. **ConsensusTool** (extends WorkflowTool)
   - Simple API: prompt + level
   - Handles workflow internally (user doesn't see step/findings)
   - Uses BandSelector for model selection
   - Implements free model failover from dynamic-model-availability.md

2. **TierManager**
   - `get_tier_models(level: int) -> List[str]` - Returns additive model list
   - Uses BandSelector queries, no hardcoded lists
   - Implements failover for free models

3. **RoleAssigner**
   - `get_tier_roles(level: int, domain: str) -> List[str]` - Returns additive role list
   - Supports domains: code_review, security, architecture, general
   - Easy to extend for new domains

4. **SynthesisEngine**
   - Aggregates all model responses
   - Identifies consensus and disagreements
   - Generates executive summary

### 3.4 Failover Integration

**Free Model Handling (from dynamic-model-availability.md ADR):**
```python
class TierManager:
    def get_available_models(self, level: int) -> List[str]:
        """Get models with failover for transient free model availability."""

        # Level 1: Free models (multiple failover attempts)
        free_models = selector.get_models_by_cost_tier("free", limit=5)
        available_free = []
        for model in free_models:
            if self._check_availability(model):
                available_free.append(model)
            if len(available_free) >= 3:
                break

        # If we got 3 free models, we're good for Level 1
        if level == 1:
            return available_free[:3]

        # Level 2: Add economy models (should be stable, no failover)
        economy_models = selector.get_models_by_cost_tier("economy", limit=3)
        tier2 = available_free[:3] + economy_models

        if level == 2:
            return tier2

        # Level 3: Add premium models (should be stable, alert if fail)
        premium_models = selector.get_models_by_cost_tier("premium", limit=2)
        return tier2 + premium_models
```

**Paid Model Handling:**
- Single attempt per model
- Alert if 404/429 (indicates deprecation needed)
- Log to monitoring for manual review

---

## 4. Migration Path

### Week 1: Build Replacement

**Tasks:**
1. Create `tools/custom/consensus.py`
   - Implement ConsensusTool (WorkflowTool)
   - Simple API: prompt + level
   - Internal workflow management (no exposed step/findings)

2. Create `tools/custom/consensus_models.py`
   - TierManager class
   - BandSelector integration
   - Failover logic for free models
   - Alert logic for paid models

3. Create `tools/custom/consensus_roles.py`
   - RoleAssigner class
   - Domain-specific role mappings
   - Extensible for new domains

4. Create `tools/custom/consensus_synthesis.py`
   - SynthesisEngine class
   - Consensus analysis
   - Executive summary generation

**Tests:**
- Unit tests for TierManager (additive tiers)
- Unit tests for RoleAssigner (role mappings)
- Integration test for free model failover
- End-to-end test for full consensus workflow

### Week 2: Add Backward Compatibility

**Tasks:**
1. Add deprecation warnings to old tools
   ```python
   @deprecated(version="2.0.0", replacement="consensus")
   class SmartConsensusV2Tool(WorkflowTool):
       """DEPRECATED: Use 'consensus' tool instead."""
   ```

2. Create parameter mapping
   - Map old `org_level` to new `level`
   - startup → level 1
   - scaleup → level 2
   - enterprise → level 3

3. Add migration guide to docs
   - `docs/migration/consensus-tool-migration.md`
   - Examples for each old tool → new tool

**Tests:**
- Test old API calls with deprecation warnings
- Test parameter mapping

### Week 3: User Communication & Testing

**Tasks:**
1. Update MCP server tool registry
   - Mark old tools as deprecated
   - Add new `consensus` tool

2. Update documentation
   - Tool catalog (COMPLETE_TOOL_LLM_MATRIX.md)
   - User guide with examples
   - Migration FAQ

3. Beta testing with users
   - Test with real use cases
   - Gather feedback on API simplicity
   - Verify cost tracking accuracy

**Deliverables:**
- Updated documentation
- Beta test results
- User feedback incorporated

### Week 4: Deprecation & Cleanup

**Tasks:**
1. Remove old tools from MCP registry
   - layered_consensus
   - smart_consensus
   - smart_consensus_v2
   - smart_consensus_simple

2. Archive old files (don't delete immediately)
   ```
   tools/custom/deprecated/layered_consensus.py
   tools/custom/deprecated/smart_consensus.py
   tools/custom/deprecated/smart_consensus_v2.py
   ```

3. Keep useful support modules
   - smart_consensus_cache.py → Reusable caching
   - smart_consensus_monitoring.py → Metrics collection
   - Delete: config, recovery, streaming, health (not needed for simpler design)

4. Update tests
   - Remove tests for deprecated tools
   - Expand tests for new `consensus` tool

**Deliverables:**
- Clean tools/custom/ directory
- Updated test suite (100% passing)
- Final migration guide

---

## 5. Domain-Specific Extensions

**Easy to Create New Consensus Domains:**

### Example: Security Consensus
```python
# tools/custom/consensus_roles.py

DOMAIN_ROLES = {
    "code_review": {
        1: ["code_reviewer", "security_checker", "technical_validator"],
        2: ["code_reviewer", "security_checker", "technical_validator",
            "senior_developer", "system_architect", "devops_engineer"],
        3: ["code_reviewer", "security_checker", "technical_validator",
            "senior_developer", "system_architect", "devops_engineer",
            "lead_architect", "technical_director"],
    },
    "security": {
        1: ["security_checker", "vulnerability_scanner", "compliance_validator"],
        2: ["security_checker", "vulnerability_scanner", "compliance_validator",
            "penetration_tester", "security_architect", "threat_modeler"],
        3: ["security_checker", "vulnerability_scanner", "compliance_validator",
            "penetration_tester", "security_architect", "threat_modeler",
            "security_director", "compliance_officer"],
    },
    "architecture": {
        1: ["system_architect", "technical_validator", "integration_specialist"],
        2: ["system_architect", "technical_validator", "integration_specialist",
            "lead_architect", "performance_engineer", "scalability_expert"],
        3: ["system_architect", "technical_validator", "integration_specialist",
            "lead_architect", "performance_engineer", "scalability_expert",
            "technical_director", "enterprise_architect"],
    },
}
```

**Usage:**
```python
# Security-focused consensus
{
  "prompt": "Evaluate the security of our authentication system",
  "level": 2,
  "domain": "security"
}

# Architecture-focused consensus
{
  "prompt": "Should we adopt microservices architecture?",
  "level": 3,
  "domain": "architecture"
}
```

---

## 6. Benefits of New Design

### For Users
- **Simple API**: Just prompt + level (1-3)
- **Predictable Costs**: Level 1 = $0, Level 2 = ~$0.50, Level 3 = ~$5
- **Additive Value**: Higher levels include all lower level perspectives
- **Domain Flexibility**: code_review, security, architecture, general

### For Developers
- **No Hardcoded Models**: Uses BandSelector exclusively
- **Easy Extensions**: New domains = just add role mappings
- **Automatic Adaptation**: When models.csv updates, tool adapts
- **Proper Failover**: Free models handled correctly (transient availability)

### For Maintenance
- **Single Tool**: 1 tool instead of 4 overlapping tools
- **Less Code**: ~500 lines vs 13,384 lines (96% reduction)
- **Clear Architecture**: Tier → Models → Roles → Synthesis
- **Better Testing**: Focused test coverage on one implementation

---

## 7. Cost Analysis

### Current State (per consensus call)
**smart_consensus_v2 with enterprise:**
- 8 models (mix of free and premium)
- Unpredictable cost: $0 - $10 depending on which models available
- No clear failover strategy

### New Design (per consensus call)
**Level 1 (Foundation):**
- 3 free models
- Cost: $0
- Use case: Quick validation, initial review

**Level 2 (Professional):**
- 3 free models + 3 economy models
- Cost: ~$0.50 (assuming 1K tokens input, 2K tokens output per model)
- Use case: Standard development decisions

**Level 3 (Executive):**
- 6 models from Level 2 + 2 premium models
- Cost: ~$5.00 (premium models are expensive but thorough)
- Use case: Critical architectural decisions, major investments

**Cost Savings:**
- Level 1: Same as current free-only mode
- Level 2: 50% less than current scaleup (no premium waste)
- Level 3: More expensive but comprehensive and PREDICTABLE

---

## 8. Testing Strategy

### Unit Tests
```python
def test_tier_manager_additive():
    """Verify Level 2 includes Level 1's exact models."""
    manager = TierManager()
    tier1 = manager.get_tier_models(1)
    tier2 = manager.get_tier_models(2)

    # Level 2 should START with Level 1's models
    assert tier2[:3] == tier1
    assert len(tier2) == 6

def test_free_model_failover():
    """Verify failover tries multiple free models."""
    manager = TierManager()

    # Mock first 2 free models as unavailable
    with patch.object(manager, '_check_availability') as mock_check:
        mock_check.side_effect = [False, False, True, True, True]

        models = manager.get_available_models(level=1)

        # Should have tried multiple models
        assert mock_check.call_count >= 3
        assert len(models) == 3
```

### Integration Tests
```python
def test_consensus_level_1_free_only():
    """Test Level 1 uses only free models."""
    result = consensus_tool.execute({
        "prompt": "Review this code",
        "level": 1
    })

    # Verify all models were free
    assert all(m in FREE_TIER for m in result.models_used)
    assert result.total_cost == 0.0

def test_consensus_level_3_additive():
    """Test Level 3 includes all Level 1 + 2 models."""
    result = consensus_tool.execute({
        "prompt": "Should we rewrite in Rust?",
        "level": 3
    })

    # Should have 8 total models (3 free + 3 economy + 2 premium)
    assert len(result.models_used) == 8
    assert result.total_cost > 1.0  # Premium models were used
```

### End-to-End Tests
```python
def test_consensus_full_workflow():
    """Test complete consensus workflow from user prompt to synthesis."""
    result = consensus_tool.execute({
        "prompt": "Evaluate microservices migration strategy",
        "level": 2,
        "domain": "architecture"
    })

    # Verify structure
    assert result.prompt == "Evaluate microservices migration strategy"
    assert result.level == 2
    assert len(result.perspectives) == 6  # 6 models for Level 2
    assert result.synthesis is not None
    assert result.consensus_points is not None
    assert result.disagreements is not None
```

---

## 9. Success Metrics

### User Experience
- ✅ Parameter count: 7 → 2 (71% reduction)
- ✅ Required parameters: 6 → 2 (67% reduction)
- ✅ API complexity: Complex workflow → Simple request

### Code Quality
- ✅ Total lines: 13,384 → ~500 (96% reduction)
- ✅ Number of tools: 4 → 1 (75% reduction)
- ✅ Hardcoded models: Yes → No (BandSelector integration)

### Architecture Compliance
- ✅ Uses centralized model registry (models.csv + bands_config.json)
- ✅ Implements additive tier architecture
- ✅ Handles free model transient availability
- ✅ Alerts on paid model failures
- ✅ Domain extensibility (new consensus types easy to add)

---

## 10. Risk Mitigation

### Risk 1: User Disruption
**Mitigation:**
- 2-week backward compatibility period
- Deprecation warnings with migration examples
- Comprehensive migration guide
- Parameter mapping (org_level → level)

### Risk 2: Model Availability Issues
**Mitigation:**
- Implement failover from dynamic-model-availability.md ADR
- Multiple free model attempts before economy fallback
- Health checks with caching (5-minute TTL)
- Monitoring and alerts for paid model failures

### Risk 3: Cost Overruns
**Mitigation:**
- Clear cost tiers (Level 1 = $0, Level 2 = ~$0.50, Level 3 = ~$5)
- Optional `max_cost` parameter for override
- Cost tracking and reporting
- Default to Level 2 (balanced cost/quality)

### Risk 4: Performance Regression
**Mitigation:**
- Keep smart_consensus_cache.py for caching
- Parallel execution for models (where possible)
- Response streaming for large outputs
- Performance benchmarks before release

---

## 11. Documentation Requirements

### User Documentation
1. **Tool Guide** (`docs/tools/consensus.md`)
   - Quick start examples
   - Level descriptions (1, 2, 3)
   - Domain options
   - Cost guidance

2. **Migration Guide** (`docs/migration/consensus-tool-migration.md`)
   - Old tool → New tool mapping
   - Parameter conversion examples
   - FAQ for common migration questions

3. **API Reference** (MCP tool schema)
   - Parameter descriptions
   - Required vs optional fields
   - Example requests/responses

### Developer Documentation
1. **Architecture Document** (`docs/development/architecture/consensus-tool.md`)
   - TierManager design
   - RoleAssigner design
   - SynthesisEngine design
   - BandSelector integration

2. **Extension Guide** (`docs/development/guides/consensus-domains.md`)
   - How to add new domains
   - Role definition patterns
   - Testing requirements

3. **Failover Documentation** (already exists in dynamic-model-availability.md ADR)
   - Reference in tool documentation

---

## 12. Next Steps

### Immediate Actions (This Week)
1. **Review this plan** - Confirm architecture aligns with original intent
2. **Decide on timeline** - 4-week plan or faster?
3. **Assign resources** - Who will implement?

### Implementation Sequence
1. **Week 1**: Build replacement tool
2. **Week 2**: Add backward compatibility
3. **Week 3**: User communication & testing
4. **Week 4**: Deprecation & cleanup

### Ongoing
- Monitor failover metrics
- Adjust band thresholds as AI industry improves
- Add new domains as needed (security, architecture, etc.)

---

## Appendix A: File Comparison

### Current State (13,384 lines)
```
tools/custom/layered_consensus.py          - 400 lines
tools/custom/smart_consensus.py            - 800 lines
tools/custom/smart_consensus_v2.py         - 600 lines
tools/custom/smart_consensus_simple.py     - 300 lines
tools/custom/smart_consensus_cache.py      - 500 lines
tools/custom/smart_consensus_recovery.py   - 600 lines
tools/custom/smart_consensus_streaming.py  - 700 lines
tools/custom/smart_consensus_config.py     - 400 lines
tools/custom/smart_consensus_health.py     - 500 lines
tools/custom/smart_consensus_monitoring.py - 400 lines
```

### Proposed State (~1,200 lines)
```
tools/custom/consensus.py           - 400 lines (main tool)
tools/custom/consensus_models.py    - 300 lines (TierManager, BandSelector integration)
tools/custom/consensus_roles.py     - 200 lines (RoleAssigner, domain mappings)
tools/custom/consensus_synthesis.py - 300 lines (SynthesisEngine)

# Keep useful modules
tools/custom/smart_consensus_cache.py      - 500 lines (reusable caching)
tools/custom/smart_consensus_monitoring.py - 400 lines (metrics)
```

**Total: 2,100 lines (84% reduction from 13,384)**

---

## Appendix B: Example API Calls

### Level 1: Quick Validation (Free)
```python
{
  "prompt": "Review this authentication code for security issues",
  "level": 1
}
```

**Response:**
- 3 free models consulted
- 3 professional perspectives (code_reviewer, security_checker, technical_validator)
- Cost: $0
- Time: ~10 seconds

### Level 2: Standard Development (Economy)
```python
{
  "prompt": "Should we migrate from REST to GraphQL?",
  "level": 2,
  "domain": "architecture"
}
```

**Response:**
- 6 models consulted (3 free + 3 economy)
- 6 professional perspectives (from architecture domain)
- Cost: ~$0.50
- Time: ~20 seconds

### Level 3: Critical Decision (Premium)
```python
{
  "prompt": "Evaluate rewriting our platform in Rust vs staying with Python",
  "level": 3,
  "domain": "architecture"
}
```

**Response:**
- 8 models consulted (3 free + 3 economy + 2 premium)
- 8 professional perspectives (complete architecture team)
- Cost: ~$5.00
- Time: ~30 seconds
- Includes: Consensus analysis, disagreement identification, executive summary

---

**This plan preserves the original architectural vision while dramatically simplifying the user experience and code maintenance.**
