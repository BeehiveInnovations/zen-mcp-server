# PreCommit工具 - 预提交验证

**通过工作流驱动调查对跨多个仓库的暂存/未暂存git更改进行全面审查**

`precommit`工具在提交前提供git更改的彻底验证，确保代码质量、需求合规性，并防止跨多个仓库的回归。此工作流工具指导Claude通过多个步骤系统调查git更改、仓库状态和文件修改，然后提供专家验证。

## 思考模式

**默认为`medium`（8,192 tokens）。** 对于关键发布当彻底验证证明token成本合理时使用`high`或`max`。

## 工作流如何运作

precommit工具实现了**结构化工作流**以进行全面更改验证：

**调查阶段（Claude主导）：**
1. **步骤1**：Claude使用直接陈述（"我将检查..."而不是"让我检查..."）说明验证策略
2. **步骤2**：Claude检查更改、差异、依赖关系，进行强制性更深入调查
3. **步骤3+**：Claude执行最终验证（强制最少3步）
4. **整个过程**：Claude跟踪发现、相关文件和问题，进行关键步骤验证
5. **完成**：仅在最少步骤后，Claude发出完成信号并创建更改集文件

**对于延续**：当使用`continuation_id`进行外部验证时，Claude将立即收集git更改并进行专家分析，无需最少步骤要求。

**专家验证阶段：**
在Claude完成调查后（除非precommit_type为**internal**）：
- 所有更改及其上下文的完整摘要
- 识别的潜在问题和回归
- 需求合规性评估
- 安全提交的最终建议

**特别说明**：
- 默认验证类型为**external**（使用专家模型进行额外审查）
- 要跳过专家验证，明确请求"不使用任何其他模型"或将precommit_type设置为"internal"
- **关键**：强制最少3步 - 工具将阻止在最终步骤之前设置`next_step_required=false`
- **强制性**：必须为外部验证创建更改集文件（zen_precommit.changeset）

## 模型推荐

预提交验证显著受益于具有扩展上下文窗口的模型（如Gemini Pro），它们可以同时分析跨多个文件和仓库的广泛更改集。这种全面视图能够检测跨文件依赖关系、架构不一致性和集成问题，这些在由于上下文约束而孤立审查更改时可能被错过。

## 视觉示例

<div align="center">
  <img src="https://github.com/user-attachments/assets/584adfa6-d252-49b4-b5b0-0cd6e97fb2c6" width="950">
</div>

**使用的提示：**
```
现在使用gemini执行审查和预提交，确保满足原始需求，没有代码或
逻辑重复，一切都应按预期工作
```

多么美妙！Claude使用了两次`precommit`和一次`codereview`，实际上在提交前发现并修复了两个关键错误！

### 真实世界示例

这是一个Claude被要求检查*它*被要求做出的更改的示例。它的**发布所有更改**建议是在一系列严格提示后做出的，其中它从不同角度（性能、错误、反模式等）检查了小组更改。在确认单元测试通过后，它首先用O3进行了初始审查；结果干净 - 一切都很好。O3很满意，一切看起来都很棒。

然后它与Gemini 2.5 Pro分享了更改和相关代码 - 以下是结果：

```
⏺ zen:precommit (MCP)(step: "最终验证完成。所有更改都已彻底分析并准备好
                     提交。修改成功修复了4个GitHub CI测试失败，具有高质量、防御性
                     实施，保持架构完整性和编码标准。未检测到问题或回归
                      。", step_number: 4, total_steps: 4, next_step_required: false, findings: "提交
                     建议：✅ 批准\n\n更改摘要：\n✅ 修复了4个GitHub CI测试失败：\n   -
                     test_openrouter_with_restrictions（Mock迭代问题）  \n   - test_execute_with_branching
                     （缺少元数据）\n   - test_execute_with_revision（缺少元数据）\n   - test_metadata_preserved
                      （Provider类型AttributeError）\n\n✅ 实施质量已验证：\n   - 具有适当类型检查的防御性编程
                     \n   - 具有有意义回退的错误处理\n   - 保持向后兼容性\n   - 遵循编码标准（更改中无hasattr/getattr）\n   -
                     保持架构模式\n\n✅ 全面测试：\n   - 所有原本失败的测试
                     通过\n   - 受影响功能：37/37测试通过\n   - 提供商系统：16/16测试通过  \n   -
                      模块导入正常工作\n   - 未检测到回归\n\n✅ 更改影响评估：\n   -
                     最小、有针对性的更改\n   - 无安全或性能问题\n   - 保持API
                     兼容性\n   - 更改有良好文档和清楚注释\n\n建议：这些更改
                      可以安全提交，将解决GitHub CI失败而不产生任何负面影响。",
  ⎿  {
       "status": "calling_expert_analysis",
       "step_number": 4,
     … +169行（ctrl+r展开）

⏺ 🔍 预提交验证完成

  基于使用O3和Gemini 2.5 Pro模型的全面分析，我可以提供以下评估：

  ✅ 需要关键修复后批准

  更改成功修复了所有4个GitHub CI测试失败，并实施了防御性编程
  模式。但是，专家分析识别出一个关键问题，必须在提交前解决：

  🚨 [高优先级] 发现关键问题

  tools/base.py中不一致的提供商处理
  - 位置：tools/base.py第~1833行_create_continuation_offer_response方法
  - 问题：防御性提供商处理模式应用于2个位置但错过了第3个位置
  - 影响：在延续场景中有AttributeError风险：'str'对象没有'get_provider_type'属性
  - 需要修复：将相同的防御性模式应用于错过的位置
```

Gemini发现的一个微妙但关键的问题，Claude + O3都错过了。这就是使用Zen运行这些工作流的力量。

## 示例提示

```
使用zen执行彻底的预提交，确保没有引入新的回归或错误
```

## 关键功能

- **递归仓库发现** - 查找包括嵌套的所有git仓库
- **根据需求验证更改** - 确保实施与意图匹配
- **检测不完整更改** - 查找从未调用的添加函数、缺少的测试等
- **多仓库支持** - 一次性审查跨多个仓库的更改
- **可配置范围** - 审查暂存、未暂存或与分支比较
- **安全重点** - 捕获暴露的秘密、新代码中的漏洞
- **智能截断** - 处理大型差异而不超过上下文限制
- **跨文件依赖分析** - 识别跨模块的破坏性更改
- **测试覆盖验证** - 确保新代码有适当的测试覆盖
- **回归检测** - 与需求比较以防止范围蔓延

## 工具参数

**工作流调查参数（在逐步过程中使用）：**
- `step`：使用直接陈述给另一工程师的技术简报（必需，禁止：大代码片段）
- `step_number`：验证序列中的当前步骤号（必需，从1开始）
- `total_steps`：估计的总调查步骤数（强制最少3步）
- `next_step_required`：是否需要另一个调查步骤（关键：在最终步骤前必须为true）
- `findings`：实际调查的具体发现和证据（必需，无模糊语言）
- `files_checked`：调查期间检查的所有文件
- `relevant_files`：与更改直接相关的文件
- `relevant_context`：受更改影响的方法/函数/类
- `issues_found`：识别的问题及严重性级别
- `precommit_type`：要执行的验证类型（external/internal，默认：external - 除非明确告知否则始终使用external）
- `backtrack_from_step`：要回溯的步骤号（用于修订）
- `images`：需求屏幕截图、设计模型用于验证

**初始配置（在步骤1中使用）：**
- `path`：搜索仓库的起始目录（步骤1必需，必须是绝对路径）
- `prompt`：更改的原始用户请求描述（上下文必需）
- `model`：auto|pro|flash|flash-2.0|flashlite|o3|o3-mini|o4-mini|gpt4.1|gpt5|gpt5-mini|gpt5-nano（默认：服务器默认）
- `compare_to`：与分支/标签比较而不是本地更改（可选）
- `severity_filter`：critical|high|medium|low|all（默认：all）
- `include_staged`：在审查中包含暂存更改（默认：true）
- `include_unstaged`：在审查中包含未提交更改（默认：true）
- `focus_on`：要关注的具体方面
- `temperature`：响应温度（默认：0.2）
- `thinking_mode`：minimal|low|medium|high|max（默认：medium，仅Gemini）
- `use_websearch`：启用最佳实践的网络搜索（默认：true）
- `use_assistant_model`：是否使用专家验证阶段（默认：true，设置为false仅使用Claude）
- `continuation_id`：继续之前的验证讨论

## 使用示例

**基本预提交验证：**
```
"使用zen precommit在提交前验证我的更改"
```

**安全重点验证：**
```
"用gemini pro对认证更改执行预提交安全审查"
```

**多仓库验证：**
```
"用o3验证此工作区中所有仓库的更改"
```

**与特定分支比较：**
```
"用gemini pro使用precommit将当前更改与main分支比较"
```

**带需求上下文：**
```
"预提交验证确保新支付功能满足FEATURE_SPEC.md中的需求"
```

## 验证范围

工具自动发现并验证：

**仓库发现：**
- 递归搜索所有`.git`目录
- 处理嵌套仓库和子模块
- 可配置搜索深度以防止过度递归

**更改分析：**
- 暂存更改（`git diff --cached`）
- 未暂存更改（`git diff`）
- 应该添加的未跟踪文件
- 已删除文件及其影响

**跨仓库影响：**
- 仓库间的共享依赖
- 影响其他仓库的API契约更改
- 具有系统范围影响的配置更改

## 验证类别

**完整性检查：**
- 新函数/类有相应测试
- API更改的文档已更新
- 配置文件根据需要更新
- 数据库更改的迁移脚本

**质量保证：**
- 代码遵循项目标准
- 无明显错误或逻辑错误
- 考虑性能影响
- 解决安全漏洞

**需求合规性：**
- 实施与原始需求匹配
- 无范围蔓延或未授权更改
- 满足所有验收标准
- 适当处理边缘情况

**集成安全性：**
- 破坏性更改得到适当记录
- 在需要时保持向后兼容性
- 依赖关系正确更新
- 环境特定更改已验证

## 最佳实践

- **提供清楚上下文**：包含原始需求或功能描述
- **用于重大更改**：对功能、重构或安全更新最有价值
- **最终提交前审查**：在进入主分支前捕获问题
- **包含视觉上下文**：需求或预期行为的屏幕截图
- **聚焦验证范围**：使用`focus_on`参数处理特定关注点
- **多阶段验证**：使用延续进行迭代改进

## 输出格式

验证结果包括：
- **更改摘要**：跨仓库修改内容的概览
- **需求合规性**：更改与原始意图的匹配程度
- **完整性评估**：缺少的测试、文档或相关更改
- **安全审查**：潜在漏洞或暴露的秘密
- **集成影响**：跨仓库和跨模块影响
- **建议**：提交前的具体行动

## 何时使用PreCommit与其他工具

- **使用`precommit`**：在git提交前验证更改，确保需求合规性
- **使用`codereview`**：一般代码质量评估，无git上下文
- **使用`debug`**：诊断特定运行时问题
- **使用`analyze`**：理解现有代码，无验证上下文
