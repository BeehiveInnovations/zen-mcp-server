# Refactor工具 - 智能代码重构

**通过工作流驱动调查进行全面重构分析，采用自顶向下分解策略**

`refactor`工具提供智能代码重构建议，专注于自顶向下分解和系统化代码改进。此工作流工具强制对代码异味、分解机会和现代化可能性进行多步骤系统调查，确保在提供带有精确实施指导的专家重构建议之前进行彻底分析。

## 思考模式

**默认为`medium`（8,192 tokens）。** 对于复杂遗留系统使用`high`（值得为彻底重构计划投资），对于需要深度分析的极其复杂代码库使用`max`。

## 工作流如何运作

refactor工具实现了**结构化工作流**以进行系统化重构分析：

**调查阶段（Claude主导）：**
1. **步骤1**：Claude描述重构计划并开始分析代码结构
2. **步骤2+**：Claude检查代码异味、分解机会和现代化可能性
3. **整个过程**：Claude跟踪发现、相关文件、重构机会和置信度
4. **完成**：一旦调查彻底，Claude发出完成信号

**专家分析阶段：**
在Claude完成调查后（除非置信度为**complete**）：
- 完整的重构机会摘要
- 按影响优先排序的建议
- 带行号的精确实施指导
- 重构策略的最终专家评估

这个工作流确保在专家建议之前进行有条理的调查，产生更有针对性和有价值的重构计划。

## 模型推荐

refactor工具在具有大上下文窗口的模型（如Gemini Pro（1M tokens））上表现出色，可以同时分析整个文件和复杂代码库。这种全面视图能够检测跨文件依赖关系、架构模式和重构机会，这些在由于上下文约束而以较小块审查代码时可能会错过。

## 示例提示

```
"使用gemini pro将my_crazy_big_class.m分解为更小的扩展"
"使用zen的refactor将all_in_one_sync_code.swift分解为可维护的扩展"
```

💡**强大提示示例**以充分利用Claude + Flash的1M上下文：
```
"首先，思考认证模块如何工作，找到相关类并找到
任何代码异味，然后使用zen的refactor要求flash确认您的发现，但要求
它找到额外的代码异味和任何其他快速胜利，然后修复这些问题"
```

这导致Claude首先执行其自己的专家分析，鼓励它批判性思考并识别项目代码内的链接。然后它提示`flash`用提示审查相同代码 - 防止它重复Claude的发现并鼓励它探索Claude*没有*发现的其他领域。

## 关键功能

- **智能优先级** - 如果代码庞大且需要首先分解，将拒绝处理低优先级问题，有助于识别管理不善的类和文件，需要在细节工作之前进行结构改进
- **自顶向下分解策略** - 系统地分析文件 → 类 → 函数级别
- **四种重构类型**：`codesmells`（检测反模式）、`decompose`（分解大组件）、`modernize`（更新语言特性）、`organization`（改善结构）
- **精确行号引用** - 为Claude提供实施更改的确切行号
- **特定语言指导** - 针对Python、JavaScript、Java、C#、Swift等的定制建议
- **样式指南集成** - 使用现有项目文件作为模式参考
- **保守方法** - 仔细的依赖分析以防止破坏性更改
- **多文件分析** - 理解跨文件关系和依赖
- **优先级排序** - 推荐重构更改的实施顺序
- **图像支持**：分析代码架构图、遗留系统图表：`"使用gemini pro和当前架构图重构这个遗留模块"`

## 重构类型（渐进优先级系统）

**1. `decompose`（关键优先级）** - 具有自适应阈值的上下文感知分解：

**自动分解**（关键严重性 - 阻止所有其他重构）：
- 文件 >15,000 LOC，类 >3,000 LOC，函数 >500 LOC

**评估分解**（上下文严重性 - 智能评估）：
- 文件 >5,000 LOC，类 >1,000 LOC，函数 >150 LOC
- 仅在真正改善可维护性时推荐
- 尊重遗留稳定性、领域复杂性、性能约束
- 考虑大小合理的合法情况（算法、状态机、生成代码）

**2. `codesmells`** - 仅在分解完成后应用：
- 检测长方法、复杂条件、重复代码、魔法数字、糟糕命名

**3. `modernize`** - 仅在分解完成后应用：
- 更新到现代语言特性（f-strings、async/await等）

**4. `organization`** - 仅在分解完成后应用：
- 改善逻辑分组、关注点分离、模块结构

**渐进分析：** 该工具执行自顶向下检查（更糟 → 坏 → 更好），如果首先需要关键分解，则拒绝处理较低优先级问题。它理解大型文件和类会造成认知超载，必须在细节工作有效之前解决。无法安全分解的遗留代码以更高的容忍阈值和上下文敏感豁免处理。

## 工具参数

**工作流调查参数（在逐步过程中使用）：**
- `step`：当前调查步骤描述（每个步骤必需）
- `step_number`：重构序列中的当前步骤号（必需）
- `total_steps`：估计的总调查步骤数（可调整）
- `next_step_required`：是否需要另一个调查步骤
- `findings`：此步骤中的发现和重构机会（必需）
- `files_checked`：调查期间检查的所有文件
- `relevant_files`：直接需要重构的文件（步骤1中必需）
- `relevant_context`：需要重构的方法/函数/类
- `issues_found`：带严重性和类型的重构机会
- `confidence`：分析完整性的置信度（exploring/incomplete/partial/complete）
- `backtrack_from_step`：要回溯的步骤号（用于修订）
- `hypothesis`：对重构优先级的当前评估

**初始配置（在步骤1中使用）：**
- `prompt`：重构目标、上下文和具体关注领域的描述（必需）
- `refactor_type`：codesmells|decompose|modernize|organization（默认：codesmells）
- `model`：auto|pro|flash|flash-2.0|flashlite|o3|o3-mini|o4-mini|gpt4.1|gpt5|gpt5-mini|gpt5-nano（默认：服务器默认）
- `focus_areas`：要关注的具体领域（如'performance'、'readability'、'maintainability'、'security'）
- `style_guide_examples`：作为样式/模式参考的可选现有代码文件（绝对路径）
- `thinking_mode`：minimal|low|medium|high|max（默认：medium，仅Gemini）
- `use_assistant_model`：是否使用专家分析阶段（默认：true，设置为false仅使用Claude）
- `continuation_id`：多轮对话的线程延续ID

## 使用示例

**分解分析：**
```
"分析UserController.java的分解机会 - 它变得难以管理"
```

**代码异味检测：**
```
"使用gemini用high思考模式识别认证模块中的代码异味"
```

**现代化：**
```
"现代化legacy_parser.py以使用现代Python特性，遵循examples/modern_patterns.py"
```

**组织改进：**
```
"重构src/utils/以获得更好的组织，专注于可维护性和可读性"
```

**遗留系统重构：**
```
"使用pro和max思考分析这个10,000行遗留文件的分解策略"
```

## 重构策略

**自顶向下分析：**
1. **文件级别**：识别需要拆分的超大文件
2. **类级别**：找到责任过多的类
3. **函数级别**：定位过于复杂或冗长的函数
4. **代码质量**：解决异味、现代化和组织

**上下文感知决策：**
- **领域复杂性**：某些领域合理需要更大的类
- **性能约束**：关键路径代码可能抵制分解
- **遗留稳定性**：旧的、有效的代码可能需要更温和的重构
- **测试覆盖**：重构建议考虑可测试性

**防止破坏性更改：**
- 在建议拆分之前分析依赖关系
- 推荐渐进迁移策略
- 识别公共API影响
- 建议向后兼容方法

## 最佳实践

- **从分解开始**：在表面改进之前解决结构问题
- **提供清楚上下文**：解释代码库目的和约束
- **使用适当的重构类型**：将类型与您的主要关注点匹配
- **包含样式示例**：引用项目中现有的结构良好的代码
- **专注于高影响领域**：针对最有问题或经常修改的代码
- **计划实施顺序**：遵循工具的排序建议
- **考虑测试覆盖**：在重大结构更改之前确保充分测试

## 输出格式

重构分析包括：
- **优先级评估**：首先需要关注什么以及为什么
- **分解策略**：具体的文件/类/函数拆分建议
- **实施计划**：逐步重构序列
- **行号引用**：更改的确切位置
- **依赖分析**：影响评估和迁移策略
- **风险评估**：潜在破坏性更改和缓解策略

## 高级功能

**自适应阈值：**
工具根据上下文调整大小阈值：
- **生成代码**：对大文件更高容忍度
- **算法实现**：识别何时大小合理
- **遗留系统**：更保守的建议
- **测试文件**：测试vs生产代码的不同标准

**跨文件重构：**
一起分析多个文件以理解：
- 可提取的共享职责
- 使重构复杂化的依赖关系
- 新抽象的机会
- 更改对代码库的影响

## 何时使用Refactor与其他工具

- **使用`refactor`**：结构改进、分解、现代化、代码组织
- **使用`codereview`**：查找错误和安全问题以及即时修复
- **使用`analyze`**：理解代码而不做出更改建议
- **使用`debug`**：解决特定运行时问题而非结构问题
