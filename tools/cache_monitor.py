"""
Cache Monitoring Tool for Zen MCP Server

This tool provides comprehensive monitoring and management capabilities
for the caching infrastructure, including statistics, health status,
and maintenance operations.
"""

import logging
from typing import List, Optional

from mcp.types import TextContent
from pydantic import Field

from tools.shared.base_models import ToolRequest
from tools.simple.base import SimpleTool

logger = logging.getLogger(__name__)


class CacheMonitorRequest(ToolRequest):
    """Request model for Cache Monitor tool"""

    action: str = Field(
        ...,
        description=(
            "Action to perform: 'stats' (get statistics), 'health' (check health), "
            "'report' (detailed report), 'cleanup' (run maintenance), "
            "'invalidate' (clear caches), 'warm' (warm caches)"
        ),
    )

    target: Optional[str] = Field(
        default=None,
        description=(
            "Target for action: 'all' (all caches), 'token' (token cache), "
            "'schema' (schema cache), 'model' (model validation cache), "
            "or specific model name for invalidation"
        ),
    )


class CacheMonitorTool(SimpleTool):
    """
    Cache monitoring and management tool.

    Provides comprehensive monitoring capabilities for the caching infrastructure,
    including real-time statistics, health monitoring, maintenance operations,
    and performance analytics.
    """

    def get_name(self) -> str:
        return "cache_monitor"

    def get_description(self) -> str:
        return (
            "CACHE MONITORING & MANAGEMENT - Monitor and manage the caching infrastructure. "
            "Get real-time statistics, health status, detailed performance reports, "
            "and perform maintenance operations. Use this to optimize cache performance, "
            "identify bottlenecks, and maintain cache health."
        )

    def requires_model(self) -> bool:
        """Cache monitor doesn't require AI model execution."""
        return False

    def get_system_prompt(self) -> str:
        """Cache monitor doesn't use AI, so no system prompt needed."""
        return ""

    def get_tool_fields(self) -> dict:
        """Return tool-specific field schemas."""
        return {
            "action": {
                "type": "string",
                "description": (
                    "Action to perform: 'stats' (get statistics), 'health' (check health), "
                    "'report' (detailed report), 'cleanup' (run maintenance), "
                    "'invalidate' (clear caches), 'warm' (warm caches)"
                ),
            },
            "target": {
                "type": "string",
                "description": (
                    "Target for action: 'all' (all caches), 'token' (token cache), "
                    "'schema' (schema cache), 'model' (model validation cache), "
                    "or specific model name for invalidation"
                ),
            },
        }

    def prepare_prompt(self, request: CacheMonitorRequest) -> str:
        """Cache monitor doesn't use AI, so no prompt needed."""
        return ""

    async def execute(self, request: CacheMonitorRequest) -> List[TextContent]:
        """
        Execute cache monitoring operation.

        Args:
            request: CacheMonitorRequest with action and optional target

        Returns:
            List of TextContent objects with formatted responses
        """
        try:
            action = request.action.lower()
            target = request.target.lower() if request.target else "all"

            if action == "stats":
                response_lines = await self._get_statistics(target)
            elif action == "health":
                response_lines = await self._check_health()
            elif action == "report":
                response_lines = await self._generate_report()
            elif action == "cleanup":
                response_lines = await self._run_cleanup(target)
            elif action == "invalidate":
                response_lines = await self._invalidate_caches(target)
            elif action == "warm":
                response_lines = await self._warm_caches()
            else:
                response_lines = [
                    f"Unknown action: {action}. Valid actions: stats, health, report, cleanup, invalidate, warm"
                ]

            # Convert to TextContent objects
            return [TextContent(type="text", text="\n".join(response_lines))]

        except Exception as e:
            logger.error(f"Cache monitor error: {e}")
            return [TextContent(type="text", text=f"Cache monitor error: {str(e)}")]

    async def _get_statistics(self, target: str) -> List[str]:
        """Get cache statistics for specified target."""
        try:
            if target == "all":
                from utils.cache_manager import get_cache_manager

                manager = get_cache_manager()
                stats = manager.get_global_stats()

                response = [
                    "üîß **CACHE STATISTICS - ALL CACHES**",
                    "",
                    "**Overall Performance:**",
                    f"‚Ä¢ Hit Rate: {stats['overall_hit_rate_percent']:.1f}%",
                    f"‚Ä¢ Total Requests: {stats['total_requests']:,}",
                    f"‚Ä¢ Memory Usage: {stats['total_memory_usage_mb']:.1f}MB / {stats['memory_limit_mb']:.0f}MB",
                    f"‚Ä¢ Memory Utilization: {stats['memory_utilization_percent']:.1f}%",
                    "",
                    "**Cache Breakdown:**",
                ]

                for cache_name, cache_stats in stats["cache_breakdown"].items():
                    response.extend(
                        [
                            "",
                            f"**{cache_name.replace('_', ' ').title()}:**",
                            f"‚Ä¢ Hit Rate: {cache_stats['hit_rate_percent']:.1f}%",
                            f"‚Ä¢ Entries: {cache_stats.get('current_size', cache_stats.get('total_entries', 0))}",
                            f"‚Ä¢ Hits: {cache_stats['hits']:,}",
                            f"‚Ä¢ Misses: {cache_stats['misses']:,}",
                        ]
                    )

                return response

            elif target == "token":
                from utils.token_cache import get_token_cache_stats

                stats = get_token_cache_stats()

                return [
                    "üî¢ **TOKEN CACHE STATISTICS**",
                    "",
                    f"‚Ä¢ Hit Rate: {stats['hit_rate_percent']:.1f}%",
                    f"‚Ä¢ Cache Size: {stats['current_size']} / {stats['capacity']} entries",
                    f"‚Ä¢ Total Requests: {stats['total_requests']:,}",
                    f"‚Ä¢ Hits: {stats['hits']:,}",
                    f"‚Ä¢ Misses: {stats['misses']:,}",
                    f"‚Ä¢ Evictions: {stats['evictions']:,}",
                    f"‚Ä¢ Memory Usage: ~{stats['memory_usage_estimate']:,} bytes",
                ]

            elif target == "schema":
                from tools.shared.schema_cache import get_schema_cache_stats

                stats = get_schema_cache_stats()

                response = [
                    "üìã **SCHEMA CACHE STATISTICS**",
                    "",
                    f"‚Ä¢ Hit Rate: {stats['hit_rate_percent']:.1f}%",
                    f"‚Ä¢ Cache Size: {stats['current_size']} / {stats['capacity']} entries",
                    f"‚Ä¢ Total Requests: {stats['total_requests']:,}",
                    f"‚Ä¢ Hits: {stats['hits']:,}",
                    f"‚Ä¢ Misses: {stats['misses']:,}",
                    f"‚Ä¢ Invalidations: {stats['invalidations']:,}",
                    f"‚Ä¢ Schema Size: {stats['total_schema_size_bytes']:,} bytes",
                    f"‚Ä¢ Tracked Tool Versions: {stats['tracked_tool_versions']}",
                ]

                if stats["tool_counts"]:
                    response.extend(["", "**Schemas by Tool:**"])
                    for tool, count in stats["tool_counts"].items():
                        response.append(f"‚Ä¢ {tool}: {count} schemas")

                return response

            elif target == "model":
                from utils.model_validation_cache import get_model_validation_cache_stats

                stats = get_model_validation_cache_stats()

                return [
                    "ü§ñ **MODEL VALIDATION CACHE STATISTICS**",
                    "",
                    f"‚Ä¢ Hit Rate: {stats['hit_rate_percent']:.1f}%",
                    f"‚Ä¢ Total Entries: {stats['total_entries']}",
                    f"‚Ä¢ Availability Cache: {stats['availability_cache_size']} entries",
                    f"‚Ä¢ Capability Cache: {stats['capability_cache_size']} entries",
                    f"‚Ä¢ Resolution Cache: {stats['resolution_cache_size']} entries",
                    f"‚Ä¢ Total Requests: {stats['total_requests']:,}",
                    f"‚Ä¢ Hits: {stats['hits']:,}",
                    f"‚Ä¢ Misses: {stats['misses']:,}",
                    f"‚Ä¢ Invalidations: {stats['invalidations']:,}",
                ]

            else:
                return [f"Unknown target: {target}. Valid targets: all, token, schema, model"]

        except ImportError as e:
            return [f"Cache system not available: {e}"]
        except Exception as e:
            return [f"Error getting statistics: {e}"]

    async def _check_health(self) -> List[str]:
        """Check cache system health status."""
        try:
            from utils.cache_manager import get_cache_manager

            manager = get_cache_manager()

            health = manager.get_health_status()
            memory_check = manager.check_memory_usage()

            status_emoji = "‚úÖ" if health["overall_healthy"] else "‚ö†Ô∏è"

            response = [
                f"{status_emoji} **CACHE SYSTEM HEALTH STATUS**",
                "",
                f"**Overall Status:** {'HEALTHY' if health['overall_healthy'] else 'UNHEALTHY'}",
                "",
                "**Health Indicators:**",
            ]

            for indicator, status in health["indicators"].items():
                status_icon = "‚úÖ" if status else "‚ùå"
                response.append(f"‚Ä¢ {indicator.replace('_', ' ').title()}: {status_icon}")

            response.extend(
                [
                    "",
                    "**Memory Status:**",
                    f"‚Ä¢ Usage: {memory_check['total_memory_mb']:.1f}MB",
                    f"‚Ä¢ Utilization: {memory_check['utilization_percent']:.1f}%",
                    f"‚Ä¢ Status: {'HEALTHY' if memory_check['is_healthy'] else 'WARNING'}",
                ]
            )

            if health["warnings"]:
                response.extend(["", "**‚ö†Ô∏è Warnings:**"])
                for warning in health["warnings"]:
                    response.append(f"‚Ä¢ {warning}")

            if health["recommendations"]:
                response.extend(["", "**üí° Recommendations:**"])
                for rec in health["recommendations"]:
                    response.append(f"‚Ä¢ {rec}")

            return response

        except ImportError as e:
            return [f"Cache system not available: {e}"]
        except Exception as e:
            return [f"Error checking health: {e}"]

    async def _generate_report(self) -> List[str]:
        """Generate detailed performance report."""
        try:
            from utils.cache_manager import get_cache_manager

            manager = get_cache_manager()

            report = manager.get_detailed_report()

            return ["üìä **DETAILED CACHE PERFORMANCE REPORT**", "", "```", report, "```"]

        except ImportError as e:
            return [f"Cache system not available: {e}"]
        except Exception as e:
            return [f"Error generating report: {e}"]

    async def _run_cleanup(self, target: str) -> List[str]:
        """Run cache cleanup/maintenance."""
        try:
            if target == "all":
                from utils.cache_manager import get_cache_manager

                manager = get_cache_manager()
                manager.cleanup_all_caches()

                return [
                    "üßπ **CACHE CLEANUP COMPLETED**",
                    "",
                    "‚Ä¢ All caches cleaned up successfully",
                    "‚Ä¢ Expired entries removed",
                    "‚Ä¢ Memory optimized",
                ]

            else:
                # Target-specific cleanup
                if target == "token":
                    from utils.token_cache import get_token_cache

                    cache = get_token_cache()
                    cache.cleanup()
                    cache_type = "Token cache"
                elif target == "schema":
                    from tools.shared.schema_cache import get_schema_cache

                    cache = get_schema_cache()
                    cache.cleanup()
                    cache_type = "Schema cache"
                elif target == "model":
                    from utils.model_validation_cache import get_model_validation_cache

                    cache = get_model_validation_cache()
                    cache.cleanup_all()
                    cache_type = "Model validation cache"
                else:
                    return [f"Unknown cleanup target: {target}"]

                return [
                    f"üßπ **{cache_type.upper()} CLEANUP COMPLETED**",
                    "",
                    f"‚Ä¢ {cache_type} cleaned up successfully",
                    "‚Ä¢ Expired entries removed",
                ]

        except ImportError as e:
            return [f"Cache system not available: {e}"]
        except Exception as e:
            return [f"Error during cleanup: {e}"]

    async def _invalidate_caches(self, target: str) -> List[str]:
        """Invalidate caches or specific models."""
        try:
            if target == "all":
                from utils.cache_manager import get_cache_manager

                manager = get_cache_manager()
                manager.invalidate_all_caches()

                return [
                    "üóëÔ∏è **ALL CACHES INVALIDATED**",
                    "",
                    "‚Ä¢ All cache entries cleared",
                    "‚Ä¢ Fresh cache state restored",
                    "‚ö†Ô∏è **Warning:** Cache performance will be temporarily reduced",
                ]

            elif target in ["token", "schema", "model"]:
                if target == "token":
                    from utils.token_cache import clear_token_cache

                    clear_token_cache()
                    cache_type = "Token cache"
                elif target == "schema":
                    from tools.shared.schema_cache import clear_schema_cache

                    clear_schema_cache()
                    cache_type = "Schema cache"
                elif target == "model":
                    from utils.model_validation_cache import get_model_validation_cache

                    cache = get_model_validation_cache()
                    # Model cache doesn't have a global clear, so we'll skip
                    cache_type = "Model validation cache"
                    return ["Model validation cache doesn't support global invalidation"]

                return [
                    f"üóëÔ∏è **{cache_type.upper()} INVALIDATED**",
                    "",
                    f"‚Ä¢ {cache_type} cleared successfully",
                    "‚ö†Ô∏è **Warning:** Cache performance will be temporarily reduced",
                ]

            else:
                # Assume it's a model name
                from utils.cache_manager import get_cache_manager

                manager = get_cache_manager()
                manager.invalidate_model_caches(target)

                return [
                    f"üóëÔ∏è **MODEL CACHES INVALIDATED: {target}**",
                    "",
                    f"‚Ä¢ All cache entries for model '{target}' cleared",
                    "‚Ä¢ Token estimation cache cleared for model",
                    "‚Ä¢ Model validation cache cleared for model",
                ]

        except ImportError as e:
            return [f"Cache system not available: {e}"]
        except Exception as e:
            return [f"Error during invalidation: {e}"]

    async def _warm_caches(self) -> List[str]:
        """Warm caches with common data."""
        try:
            from utils.cache_manager import get_cache_manager

            manager = get_cache_manager()
            manager.warm_all_caches()

            return [
                "üî• **CACHE WARMING COMPLETED**",
                "",
                "‚Ä¢ Caches warmed with common data",
                "‚Ä¢ Token cache warmed with standard prompts",
                "‚Ä¢ Performance should be improved for common operations",
                "",
                "üí° **Tip:** Run cache warming after server startup for best performance",
            ]

        except ImportError as e:
            return [f"Cache system not available: {e}"]
        except Exception as e:
            return [f"Error during cache warming: {e}"]
